// See LICENSE for license details.

package node

import chisel3._
import chisel3.util._
// import Config._

import chisel3.iotesters.{ChiselFlatSpec, Driver, PeekPokeTester, OrderedDecoupledHWIOTester}
import org.scalatest.{Matchers, FlatSpec}

import node._




class DecoupledNodeTests (DUT: DecoupledNode) extends PeekPokeTester(DUT)  {

  poke(DUT.io.LeftIO.bits,2)
  poke(DUT.io.RightIO.bits,2)
  poke(DUT.io.LeftIO.valid,1)
  poke(DUT.io.RightIO.valid,0)
  poke(DUT.io.OutIO.ready,1)

  // step(1)      
  // step(1)    
  // println(s"io.out.bits.c: ${peek(DUT.io.out.bits.c)}, io.out.bits.valid: ${peek(DUT.io.out.valid)} state: ${peek(DUT.io.out.bits.state)} should be ${2+2}")
  //      println(s"io.out.bits.c: ${peek(DUT.io.out.bits.a)}, io.out.bits.valid: ${peek(DUT.io.out.valid)}  should be ${2+2}")
  // poke(DUT.io.out.ready,0)

  for {
   i <- 0 to 20
 }
 {
  println(s"io.out.bits.c: ${peek(DUT.io.OutIO.bits.data)}, io.out.bits.valid: ${peek(DUT.io.OutIO.valid)} state: ${peek(DUT.io.OutIO.bits.state)} should be ${2+2}")
  // println(s"io.inLeft.bits: ${peek(DUT.io.inLeft.bits)}, io.inLeft.valid: ${peek(DUT.io.inLeft.valid)}, io.inLeft.Ready: ${peek(DUT.io.inLeft.ready)} ")
  step(1)    
  if (i == 3)
  {
    // poke(DUT.io.inRight.bits,2)
    poke(DUT.io.RightIO.valid,1)
  }
  if (i == 4)
  {
    poke(DUT.io.RightIO.valid,0)
    poke(DUT.io.RightIO.valid,0)
  }
}
}


class DecoupledNodeTester extends FlatSpec with Matchers {
  behavior of "DecoupledNodeSpec"

  val xLen = 32

  it should "compute gcd excellently" in {
    chisel3.iotesters.Driver(() => new DecoupledNode(xLen, 1)) { c =>
      new DecoupledNodeTests(c)
      } should be(true)
    }
  }
